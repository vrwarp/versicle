import { describe, it, expect, vi, beforeEach } from 'vitest';
import { AudioContentPipeline } from './AudioContentPipeline';
import { dbService } from '../../db/DBService';
import { useGenAIStore } from '../../store/useGenAIStore';

vi.mock('../../db/DBService', () => ({
    dbService: {
        getTTSContent: vi.fn(),
        getContentAnalysis: vi.fn(),
        getBookMetadata: vi.fn(),
        saveContentClassifications: vi.fn(),
        getTableImages: vi.fn().mockResolvedValue([]),
    }
}));

vi.mock('../../store/useTTSStore', () => ({
    useTTSStore: {
        getState: vi.fn(() => ({
            customAbbreviations: [],
            alwaysMerge: false,
            sentenceStarters: [],
            minSentenceLength: 0
        }))
    }
}));

vi.mock('../../store/useGenAIStore', () => ({
    useGenAIStore: {
        getState: vi.fn(() => ({
            contentFilterSkipTypes: [],
            isContentAnalysisEnabled: false,
            isEnabled: true,
            apiKey: null
        }))
    }
}));

vi.mock('../genai/GenAIService', () => ({
    genAIService: {
        isConfigured: vi.fn(() => false),
        configure: vi.fn(),
        detectContentTypes: vi.fn()
    }
}));

vi.mock('./TextSegmenter', () => ({
    TextSegmenter: {
        refineSegments: vi.fn((segments) => segments)
    }
}));

describe('AudioContentPipeline', () => {
    let pipeline: AudioContentPipeline;

    beforeEach(() => {
        pipeline = new AudioContentPipeline();
        vi.clearAllMocks();
    });

    describe('loadSection', () => {
        it('should load and process TTS content successfully', async () => {
            const mockSection = { sectionId: 's1', characterCount: 500 } as any;
            const mockSentences = [{ text: 'Hello world', cfi: 'cfi1' }];
            const mockMetadata = { title: 'Test Book', author: 'Test Author' };

            (dbService.getTTSContent as any).mockResolvedValue({ sentences: mockSentences });
            (dbService.getBookMetadata as any).mockResolvedValue(mockMetadata);
            (dbService.getContentAnalysis as any).mockResolvedValue(null);

            const result = await pipeline.loadSection('book1', mockSection, 0, false, 1.0);

            expect(result).toHaveLength(1);
            expect(result![0].text).toBe('Hello world');
            expect(result![0].title).toBe('Section 1');
        });

        it('should handle empty chapters gracefully', async () => {
            const mockSection = { sectionId: 's1', characterCount: 0 } as any;
            (dbService.getTTSContent as any).mockResolvedValue({ sentences: [] });
            (dbService.getBookMetadata as any).mockResolvedValue({});

            const result = await pipeline.loadSection('book1', mockSection, 0, false, 1.0);

            expect(result).toHaveLength(1);
            expect(result![0].isPreroll).toBe(true);
        });

        it('should generate preroll when enabled', async () => {
            const mockSection = { sectionId: 's1', characterCount: 500 } as any;
            const mockSentences = [{ text: 'Hello', cfi: 'cfi1' }];
            (dbService.getTTSContent as any).mockResolvedValue({ sentences: mockSentences });
            (dbService.getBookMetadata as any).mockResolvedValue({});

            const result = await pipeline.loadSection('book1', mockSection, 0, true, 1.0);

            expect(result).toHaveLength(2);
            expect(result![0].isPreroll).toBe(true);
            expect(result![0].text).toContain('Estimated reading time');
            expect(result![1].text).toBe('Hello');
        });
    });

    describe('Content Filtering', () => {
        it('should trigger onMaskFound with skipped indices when filtering is enabled', async () => {
            const mockSection = { sectionId: 's1', characterCount: 500 } as any;

            // Define sentences with sourceIndices
            const s1 = { text: 'Keep me', cfi: 'epubcfi(/6/2!/4/2/2:0)', sourceIndices: [0] };
            const s2 = { text: 'Skip me', cfi: 'epubcfi(/6/2!/4/2/4:0)', sourceIndices: [1] };

            (dbService.getTTSContent as any).mockResolvedValue({ sentences: [s1, s2] });

            // Mock content analysis response format is `semanticMap` not `contentTypes`
            // Based on DBService.ts: saveContentClassifications uses `semanticMap` property
            (dbService.getContentAnalysis as any).mockResolvedValue({
                semanticMap: [
                    // Correct range CFI generation logic:
                    // s2 cfi is /6/2!/4/2/4:0
                    // parent is /6/2!/4/2/4
                    // so rootCfi should be epubcfi(/6/2!/4/2/4) or similar range
                    // The pipeline uses generateCfiRange(start, end).
                    { rootCfi: 'epubcfi(/6/2!/4/2/4,/:0,/:0)', type: 'table' }
                ]
            });

            // But wait, groupSentencesByRoot logic:
            // "rootCfi" generated by generateCfiRange is tricky to predict exactly without running the util.
            // However, the AudioContentPipeline implementation uses the result from `groupSentencesByRoot` to detect content types.
            // If `getOrDetectContentTypes` returns results, it uses `semanticMap` from DB.

            // Wait! The key issue is that the mocked `getContentAnalysis` result `rootCfi`
            // MUST MATCH the `rootCfi` calculated by `groupSentencesByRoot` inside the pipeline.
            // The pipeline uses `cfi-utils`. Since we can't easily run cfi-utils inside the test mock accurately without deep imports,
            // we should spy on `groupSentencesByRoot` or assume a simple structure.

            // Or better: Mock `groupSentencesByRoot` on the pipeline instance prototype to force known groups.
            // Since `groupSentencesByRoot` is private, we can't easily spy on it.
            // But we can rely on `detectContentTypes` being called if we simulate a "miss"?
            // No, we want "hit".

            // Let's adjust the mock to match what the pipeline likely produces.
            // If s2 has cfi 'epubcfi(/6/2!/4/2/4:0)', its parent is likely 'epubcfi(/6/2!/4/2/4)'.
            // The pipeline generates a range.
            // Let's bypass the strict CFI matching by mocking `dbService.getContentAnalysis` to return null,
            // and `genAIService.detectContentTypes` (if we enable it) to return something.
            // BUT `detectContentSkipMask` calls `getOrDetectContentTypes`.

            // Instead, let's look at `AudioContentPipeline` line 240:
            // const groups = this.groupSentencesByRoot(...)

            // We can mock `groupSentencesByRoot` if we cast to any.
            (pipeline as any).groupSentencesByRoot = vi.fn(() => [
                { rootCfi: 'group1', segments: [s1], fullText: s1.text },
                { rootCfi: 'group2', segments: [s2], fullText: s2.text }
            ]);

            // Now we mock DB response with matching keys
            (dbService.getContentAnalysis as any).mockResolvedValue({
                semanticMap: [
                    { rootCfi: 'group2', type: 'table' }
                ]
            });

            (useGenAIStore.getState as any).mockReturnValue({
                contentFilterSkipTypes: ['table'],
                isContentAnalysisEnabled: true,
                isEnabled: true,
                apiKey: 'test-key'
            });

            const onMaskFound = vi.fn();

            // Execute
            await pipeline.loadSection('book1', mockSection, 0, false, 1.0, undefined, onMaskFound);

            // Wait for async
            await new Promise(resolve => setTimeout(resolve, 50));

            expect(onMaskFound).toHaveBeenCalled();
            const mask = onMaskFound.mock.calls[0][0];
            expect(mask.has(1)).toBe(true);
        });
    });
});
