Design Document: Offscreen Live-Rendering for Ingestion
=======================================================

1\. Executive Summary
---------------------

This document proposes a fundamental shift in how Versicle processes books during ingestion. Currently, the Text-to-Speech (TTS) engine generates Canonical Fragment Identifiers (CFIs) using a static XML parser. This often results in CFIs that are incompatible with the live browser renderer, causing the "IndexSizeError" and breaking playback for specific sentences.

The proposed solution is to move away from static parsing and instead use **Offscreen Live-Rendering**. By instantiating a hidden reader instance during the ingestion phase, we can extract text and generate CFIs from the exact same DOM structure that the user will see during playback. This guarantees 100% compatibility between the audio queue and the visual highlighter.

2\. Problem Statement: The CFI Mismatch
---------------------------------------

The core issue is a "Reality Gap" between how we read the file and how the browser displays it.

### The Static View (Current Ingestion)

When a user adds a book, we currently use a `DOMParser` to read the raw XML/HTML files inside the EPUB. This parser is strict and sees every whitespace character, newline, and tag exactly as written in the file. We calculate CFIs based on this structure.

### The Live View (Playback)

When the user reads the book, it is rendered in an iframe by `epub.js`. The browser's layout engine performs aggressive normalization:

-   It collapses multiple spaces into one.

-   It merges adjacent text nodes.

-   It ignores whitespace around block-level elements.

-   It sometimes corrects invalid HTML.

### The Consequence

Because the live DOM structure differs from the static XML structure, the offsets calculated during ingestion often point to non-existent locations in the live view. For example, the ingestion parser might see a text node at offset 500, but the browser has collapsed it to offset 450. When we try to highlight the sentence starting at 500, the browser throws an `IndexSizeError` because that index implies a string longer than what exists.

3\. Proposed Solution: Live Ingestion Renderer
----------------------------------------------

We will replace the static parsing logic with a **Live Offscreen Renderer**.

Instead of guessing what the DOM will look like, we will actually render it. During the ingestion process, the application will:

1.  Create a hidden container off-screen.

2.  Load the book into a temporary `epub.js` instance.

3.  Render each chapter sequentially.

4.  Extract text and CFIs from the *rendered* DOM.

5.  Destroy the instance.

This ensures that the CFIs we save to the database are generated by the exact same engine (the browser + `epub.js`) that will later consume them.

4\. Detailed Architecture & Workflow
------------------------------------

The new ingestion pipeline will follow these steps:

### Step 1: Preparation

-   The system creates a transient DOM element (e.g., a `div`) and styles it to be invisible and positioned off-screen (e.g., `top: -10000px`).

-   A new `ePub` object is instantiated with the file blob.

-   A `Rendition` is created, attached to the hidden container.

### Step 2: Sequential Processing

The system iterates through the book's "spine" (list of chapters):

1.  **Render:** Call the display method for the current chapter.

2.  **Wait:** Await the "rendered" event, ensuring the browser has finished layout and DOM normalization.

3.  **Access:** Gain access to the content document (the iframe's internal document).

4.  **Extract:** Run the existing sentence segmentation logic on this live `document.body`.

5.  **Generate:** Use the renderer's native methods to generate CFIs for each sentence range. This is the crucial step---we rely on the renderer to tell us "where is this sentence?" rather than calculating it manually.

### Step 3: Yielding (Time Slicing)

Since rendering happens on the main UI thread, processing a large book in one go would freeze the application.

-   The loop must implement a "yielding" strategy.

-   After processing each chapter (or a batch of chapters), the process will pause for a few milliseconds (using `setTimeout` or `requestAnimationFrame`) to allow the browser to update the UI, handle user clicks, and render progress bars.

### Step 4: Cleanup

-   Once all chapters are processed, the `Rendition` is destroyed.

-   The `ePub` instance is destroyed.

-   The hidden container is removed from the DOM to prevent memory leaks.

5\. Technical Challenges & Mitigations
--------------------------------------

### 5.1. Main Thread Blocking & UI Responsiveness

**Risk:** Rendering HTML is expensive. Ingesting a 50-chapter book creates a heavy workload on the main thread. Without mitigation, this freezes the UI, triggering "Page Unresponsive" warnings and frustrating the user.

**Mitigation Strategy:**

1.  **Progressive Yielding (Time Slicing):**

    -   We will strictly enforce a non-blocking pause (e.g., `await new Promise(r => setTimeout(r, 50))`) between chapters.

    -   This "breathing room" allows the browser's event loop to process user inputs, run animations, and update the DOM.

2.  **Granular User Feedback (The Progress UI):**

    -   **Component:** A dedicated `IngestionProgress` toast or non-blocking modal that appears immediately upon file selection.

    -   **Visual Feedback:**

        -   **Determinate Progress Bar:** A bar visualizing `(processedChapters / totalSpineItems) * 100`.

        -   **Status Label:** Dynamic text updating with each step (e.g., "Processing Chapter 5 of 42: 'Down the Rabbit-Hole'").

    -   **Interaction Design:**

        -   **Non-Blocking:** The user can continue to browse their library while ingestion happens in the background.

        -   **Cancellability:** A prominent "Cancel" button must be available. If clicked, the system aborts the loop, destroys the offscreen renderer, and cleans up any partial database entries.

        -   **Completion:** Upon success, the progress bar transitions to a "Book Added" success toast with an "Open" button.

### 5.2. Memory Consumption

**Risk:** Loading a full rendering engine and creating DOM nodes for every chapter can consume significant RAM. **Mitigation:**

-   We must ensure that we do not keep previous chapters in memory. `epub.js` usually handles this by unloading non-visible views, but we will explicitly force garbage collection hints where possible by nullifying references after extraction.

-   We will process purely sequentially, never parallelizing chapter rendering, to keep the memory footprint to a single chapter at a time.

### 5.3. Performance Impact

**Risk:** Ingestion will be slower. Static parsing is near-instant; rendering takes tens or hundreds of milliseconds per chapter. **Mitigation:**

-   This is an acceptable trade-off for correctness.

-   We can explore "Lazy Ingestion" in the future, where we only ingest the current chapter and the next one, rather than the whole book upfront. For now, we will accept the longer ingestion time for simplicity.

6\. Implementation Strategy
---------------------------

### Phase 1: Utility Creation

Develop a standalone utility function, `extractContentOffscreen`, which takes a file and returns the extracted sentences. This function will encapsulate the lifecycle of the hidden renderer.

### Phase 2: Integration

Modify the `processEpub` function in `src/lib/ingestion.ts`. Replace the section that currently uses `DOMParser` with a call to the new utility function.

### Phase 3: Error Handling

If the offscreen renderer fails (e.g., due to a malformed chapter that crashes the view), the system should have a fallback mechanism. It could log the error and skip the chapter, or attempt a fallback to the old static parser for that specific section, flagging it as "potentially unstable."

7\. Verification Plan
---------------------

We will verify the fix by running the specific scenario that currently fails:

1.  Ingest a book known to have complex markup (like *Alice in Wonderland* or *Frankenstein*).

2.  Wait for the new ingestion process to complete.

3.  Open the book in the Reader.

4.  Select a sentence that previously caused an error.

5.  Trigger "Play from Selection".

6.  Confirm that the audio starts correctly and the highlight appears, validating that the CFI is now accurate.
