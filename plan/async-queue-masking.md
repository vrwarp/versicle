Technical Design: Asynchronous Queue Masking for Low-Latency TTS
================================================================

1\. Objective
-------------

Versicle's Text-to-Speech (TTS) engine employs an "Optimistic UI" pattern to eliminate playback latency caused by expensive generative content analysis. By decoupling initial text segmentation from structural filtering (e.g., identifying tables, footnotes, or asides), the system achieves near-instantaneous "Time to First Word" while refining the audible timeline asynchronously.

2\. Conceptual Framework: The Virtualized Timeline
--------------------------------------------------

The core innovation is the transition from physical queue mutation to logical timeline projection. In traditional systems, filtering content involves splicing or re-indexing arrays, which creates complex race conditions when background tasks compete with user navigation.

### 2.1 The Invariant Index Rule

Once a section is loaded, the primary data structure (`TTSQueueItem[]`) is treated as **immutable in length**.

-   **Physical Queue**: Generated by the `AudioContentPipeline` via the "Fast Path" (local regex-based sentence segmentation).

-   **Metadata Updates**: Background analysis tasks do not remove elements; they modify the `isSkipped` boolean flag.

-   **Invariant Benefit**: An index `i` always refers to the same physical text segment for the duration of the section lifecycle, allowing the "Slow Path" to communicate updates without tracking index shifts.

### 2.2 Mask Projection

The `PlaybackStateManager` acts as a projection layer, mapping the Physical Timeline onto a Virtual Timeline visible to the UI and the audio driver.

-   **Indices**: If the Physical Timeline is `[0, 1, 2, 3, 4, 5]` and a mask exists for `{2, 3}`, the logical sequence navigated by the player is `[0, 1, 4, 5]`.

-   **Logical Length**: The count of items where `isSkipped` is false.

-   **Virtual Duration**: The sum of character lengths for all non-skipped segments, adjusted by the playback speed multiplier.

3\. Algorithm Details
---------------------

### 3.1 Adaptive Prefix Sums

Seek operations and progress bar rendering rely on a prefix sum array that ignores masked content. If an item's `isSkipped` flag is `true`, its logical length is treated as exactly `0`.

```
function calculatePrefixSums(queue):
    prefixSums = new Array(queue.length + 1)
    prefixSums[0] = 0

    for i from 0 to queue.length - 1:
        item = queue[i]
        virtualLength = 0

        if item.isSkipped is false:
            virtualLength = length(item.text)

        prefixSums[i + 1] = prefixSums[i] + virtualLength

    return prefixSums

```

**System Impacts:**

1.  **Dynamic Progress Scaling**: As background analysis identifies a large table to skip, the `totalVirtualLength` decreases. This causes the UI progress bar to "shrink" logically to represent only readable content.

2.  **Seek Accuracy**: Seeking to a specific percentage maps to the prefix sum indices, ensuring the user is never dropped into the middle of a skipped segment.

### 3.2 Non-Blocking Navigation

Navigation logic (`next()`, `prev()`) transitions from simple arithmetic increments to **Linear Visibility Scans**.

-   **Forward Navigation**:

    ```
    function getNextVisibleIndex(currentIndex, queue):
        for i from currentIndex + 1 to queue.length - 1:
            if queue[i].isSkipped is false:
                return i
        return null // Trigger section boundary

    ```

-   **Computational Cost**: O(N) in the worst case (e.g., skipping a massive appendix), but since N is typically limited to sentence counts per chapter, this remains well within the frame budget for a 60fps UI.

### 3.3 The Background Reconciliation Loop

The `AudioContentPipeline` manages the coordination between raw text extraction and the GenAI "Slow Path."

1.  **Fast Path Mapping**: During initial segmentation, `AudioContentPipeline` maintains a mapping of the logical indices (merged segments) to their source raw indices.

    -   **Structure**: `Map<MergedIndex, RawIndex[]>`

2.  **Slow Path Execution**: Generative analysis (via `GenAIService`) identifies non-readable structural blocks, marking specific **raw indices** as candidates for skipping based on user settings.

3.  **Intersection & Validation Phase**: The pipeline evaluates each merged segment. A merged segment is only marked as skipped if **all** of its constituent raw indices are marked for skipping.

4.  **Dispatch Phase**:

    ```
    function reconcileMask(mergedToRawMap, rawSkipStatus):
        indicesToSkip = []
        for mergedIndex in mergedToRawMap:
            rawIndices = mergedToRawMap[mergedIndex]

            // Merged segment is skipped ONLY if all constituents are skipped
            shouldSkipMerged = true
            for rawIndex in rawIndices:
                if rawSkipStatus[rawIndex] is false:
                    shouldSkipMerged = false
                    break

            if shouldSkipMerged is true:
                indicesToSkip.push(mergedIndex)

        dispatch markIndicesAsSkipped(indicesToSkip)

    ```

4\. State Synchronization & Concurrency
---------------------------------------

### 4.1 The Stale Update Guard (Section Keying)

Because analysis is asynchronous, a result for "Chapter 1" might arrive after the user has navigated to "Chapter 2."

**Solution**: The `AudioPlayerService` stamps every analysis request with the `sectionId`. Upon callback, it validates that the `currentSectionId` matches the request stamp. If they do not match, the update is discarded.

### 4.2 Playback Continuity Logic

If the *currently playing* item is marked as `isSkipped` by a background task:

-   **The Rule**: The current utterance is allowed to finish naturally.

-   **Justification**: Abruptly cutting off a sentence mid-word is high-friction for the user.

-   **Transition**: Since the `next()` logic is updated immediately upon the masking event, the "jump" to the next visible content occurs naturally at the next sentence boundary.

5\. Architectural Invariants
----------------------------

1.  **Initial Load Ceiling**: The time required to start audio must never exceed local regex segmentation and DB read time (<100ms).

2.  **Persistence**: The `isSkipped` state is persisted to the local database within the `TTSQueueItem` schema. Subsequent loads use the pre-filtered mask immediately.

3.  **UI/Audio Parity**: The `TTSQueue` component filters items based on `isSkipped` for visual consistency.

6\. Implementation Notes for PlaybackStateManager
-------------------------------------------------

-   **Caching**: Prefix sums are cached and only recomputed when the mask changes.

-   **Progress Calculation**:

    ```
    currentOffset = prefixSums[currentIndex] + progressInCurrentItem
    percentage = (currentOffset / totalVirtualLength) * 100

    ```
